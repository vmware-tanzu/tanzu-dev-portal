---
type: "tv-episode"
Description: "Writing Spring Boot Tests In a Reactive Kotlin Environment."
aliases: ["/0024"]
hosts: ["Bob Brindley","Tiffany Jernigan","Paul Czarkowski"]
guests: ["Mario Gray"]
Date: "2020-09-22T13:00:00-07:00"
PublishDate: "2020-09-18T00:00:00-07:00"
episode: "0024"
# 320x180 for image / banner
# once streamed, replace with youtube from below command
# wget -O static/images/tv/episodes/tanzu-tuesdays/0024-yt.jpg https://img.youtube.com/vi/wSJ4TOluzf8/mqdefault.jpg
# we didn't get an ep image, so using mario's code ep image until we get the youtube thumbnail.
episode_image: "/images/tv/episodes/tanzu-tuesdays/0024-yt.jpg"
episode_banner: "/images/tv/episodes/tanzu-tuesdays/0024-yt.jpg"
explicit: "no"
images: ["/images/tv/episodes/code/tanzu-tuesdays/0024-yt.jpg"]
title: "Bootiful Spring Deployments"
youtube: "wSJ4TOluzf8"
truncate: ""
twitch: "vmwaretanzu"

---

**Join Us** in a cloud-native app building experience that Spring Boot provides out of the box! Why guess at the state of microservices in a Kubernetes-centric scenario when Spring can help us get that status out? We will code with Kotlin on the JVM and use Spring’s declarative access to the liveness/readiness state and its health monitoring subsystem. Next, we’ll see a recent Spring Boot feature that lets us declare container build and execution parameters using a build tool like Maven or Gradle. Finally, we step into configuration state transfer and service discovery so that application runtime behavior gets defined with Kubernetes idioms like ConfigMaps and Secret. This demo will look at how to tie these characteristics of Spring and Kubernetes together to produce a resilient cloud-native application.
