---
title: Foundations
weight: 10
layout: single
team:
  - VMware Tanzu Labs
---
*This article is the first in a five-part series.*

Modern Application Developers know the secret to
successfully building modern apps in today's
competitive market is learning how to
use building blocks in a bottom-up collaborative
environment.

![Foundations](/images/outcomes/application-development-rhythm/foundations-building.jpg)

To get the most out of this series, take some time to learn more about
*modern application principles* and *practices*.

## What You Will Learn

In this first article, you will learn how to:

-   Explain the context of modern application development.
-   Describe the types of building blocks that comprise modern
    application development.
-   Describe how a modern application developer must continually
    consider trade offs and technical debt.

## Modern Application Principles and Practices

Modern Application Development improves your organization's
ability to maintain, plan to build,
or modernize existing software products that:

-   Achieve a market fit.
    Provide long-term value to your organization and customers.
-   Are subject to continual change.
-   Allow changes to be done *quickly*, *safely*, and *sustainably*.
-   Allow persistent product teams to build, evolve and maintain software.

If none of these apply, you can stop reading now.

Still here?

Great!

Older legacy application development practices include a lot of formal
processes,
bureaucracy,
and a separation of skill sets with the logic that it is necessary to use
formalized structure to *force discipline top-down* to deliver software.

Modern application development practices require just as much,
if not more discipline, than legacy processes.

Now that you have an idea about the context,
let us discuss the major types of building blocks that form the
foundation of modern application development.

## Building Blocks

There are five building block categories
that support the Modern Application Development
process:

1.  Principles
1.  Practices
1.  Patterns
1.  Methods and
    Techniques
1.  Tools and
    Technologies

You can view building block examples in each of the upcoming articles:

- [Development Building Blocks, Part 1](../dev-building-blocks-1/)
- [Development Building Blocks, Part 2](../dev-building-blocks-2/)

## Principles

Principles are foundational rules that help modern application developers
select the best practices to use to accomplish a specific task.
For example, *why* it is a good idea to combine the some of the principles
in this article that are similar in belief or behavior.

Principles are proven success factors that remain relevant for long periods of time.

At Tanzu Labs, following foundational principles makes it possible to:

- ‚ö°Ô∏è Empower teams.
- üå± Start simple.
- ü¶ã Embrace change.
- üöÄ Deliver early and often.
- üî¨ Improve continuously.
- ‚ù§Ô∏è Give back.

To find out more about Tanzu foundational principles click
[here](/outcomes/application-development-how-we-work/principles/).

There are two engineering principles that you may find particularly
useful.
They are:

- [SOLID design principles](https://en.wikipedia.org/wiki/SOLID)
- [12 Factor guidelines](https://12factor.net)

As you collaborate with other experienced modern application development
practitioners,
make sure to ask *why* they do work in a specific way,
and what principles they use to guide their work.

![Principles](/images/outcomes/application-development-rhythm/principles.jpg)

## Practices

A *practice* is a specific way the developer works to accomplish a goal, according to their work context
*principles*.
Think of *practices* as a high level method of *how* work is done without
specifying the exact steps.

The lifetime of principles is tied to the relevance of the context in which they
live.

A Modern App Developer may use multiple practices
during their daily workflow to solve problems efficiently and
safely.

Practices in this series include:

-   [Pair Programming](../../application-development/pair-programming/)

-   [Test Driven Development](../../application-development/test-driven-development/)

### Methods and Techniques

*Methods and Techniques* are processes or procedures that facilitate the
performance of the relevant practices.

Though not broad enough to be considered practices, methods and techniques
form the detailed *how* in the practitioners' work in very specific
scenarios that support the relevant *practices*.

Some of the methods and techniques you will see in this series includes:

- [Refactoring](https://refactoring.com)
- Red/Green/Refactor

## Software Patterns

Software patterns are known solutions used to solve common types of
development problem.
They are an excellent resource for providing solutions to new and
recurring software problems.

*Patterns* are also long-lived,
similar to *practices*.

Think of patterns as one of the high level *whats* of building software.

Software patterns are discovered over time,
then published so that other developers may also share and collaborate
their findings.

![Patterns](/images/outcomes/application-development-rhythm/patterns.jpg)

*Anti-patterns* are code patterns that do not provide a solution to fix
a new or recurring software problem.

## Tools and Technologies

*Tools* and *Technologies* facilitate the use of solution pattern
methods and practices,
as well as the implementation of solution patterns,
where appropriate.

As you know, the most popular tools, technologies and frameworks
available on the market today,
can quickly be replaced and considered outdated tomorrow.
One way to ensure the tools and technologies that you select
are going to be the most productive is to refer to your organization's
support for standards to collect tool selection criteria.

It's also a good idea to become proficient in how each of the tools and
technologies work, as this is the best way to minimize
friction in the Modern Apps Practitioner Workflow.

## Trade Offs, Costs and Technical Debt

Selecting the best building blocks to run your daily work
can be a challenge.

**Every activity you do,**
**and every building block you select and use,**
**will have trade offs,**
**and associated costs.**

Associated costs are measured in time, money or opportunities lost.

There are three types of costs to manage:

- Upfront Costs
- Taxes
- Debt

![Trade offs, Costs and Technical Debt](/images/outcomes/application-development-rhythm/foundations-bank.jpg)

### Upfront Costs

Upfront costs are incurred whenever a
software product teams plans,
estimates, and builds new features,
or fixes defects.

Upfront costs are also incurred when
the team spends time doing activities.

Resources are another upfront cost.
Resource costs includes compute, storage and other
infrastructures specific to the activities.

As a Modern App Developer,
you can do your part in keeping your organization's upfront costs down
by working with minimal designs.
Although this is a proven cost-effective solution,
there are drawbacks that can sometimes cause
[*Technical Debt*](#technical-debt).

### Taxes

The term *tax* describes the ongoing costs of
authoring and maintaining software products.

*Taxes* are *compulsory charges* imposed to fund activities over time.

Examples of software taxes include:

-   Software maintenance such as
    keeping the application codebases clean.

-   Use of *Platforms* or *Middleware*.

-   Tools license or subscription costs.

-   Third party dependency upgrades.

-   Developer continual learning.

It's never a good idea to avoid paying taxes for these products
because the associated software product team may be
impacted by the consequences.

### Technical Debt

*Technical Debt* is the concept where:

-   A software product team,
    or developer,
    chooses to take a shortcut,
    in a feature or design implementation,
    for an immediate benefit.

    You can expect the team or developer to remediate,
    or repay for taking
    the shortcut at a later time.

-   The more shortcuts that are taken without remediating,
    or replaying them,
    the more accumulation of "debt" will have consequences for
    the product team.
    Most of the time this results in the team slowing down.

A common example of accumulation of technical debt is when:

-   A developer chooses to deviate from software development principles
    as a short cut to move faster in the moment.

-   A developer should remediate the deviation as part of an ongoing
    code maintenance activity.

-   Development teams that continually deviate from development
    principles ultimately put the software codebase in a state that
    becomes hard to maintain and change.

Always repay your technical debt!

## Summary

In this article, you learned about:

-   Modern application development.
-   The types of building blocks that comprise modern application
    development.
-   Trade offs, Costs and Technical Debt
